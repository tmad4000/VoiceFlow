#!/usr/bin/env python3
"""
Generate or retrieve documentation for Swift package dependencies.
"""

import sys
import os
import subprocess
import tempfile
from pathlib import Path

# Import utilities from local directory
scripts_dir = Path(__file__).parent
sys.path.insert(0, str(scripts_dir))
from swift_packages import (
    get_all_dependencies,
    resolve_module_to_package,
    find_derived_data_path,
    find_package_directory_in_derived_data
)


def error_exit(message):
    """Print error message and exit."""
    print(f"Error: {message}", file=sys.stderr)
    sys.exit(1)


def run_command(cmd, cwd=None, capture_output=True):
    """Run a shell command and return output."""
    try:
        result = subprocess.run(
            cmd,
            cwd=cwd,
            capture_output=capture_output,
            text=True,
            check=True
        )
        return result.stdout.strip() if capture_output else None
    except subprocess.CalledProcessError as e:
        error_exit(f"Command failed: {' '.join(cmd)}\n{e.stderr}")


def get_package_version(package_dir):
    """Extract package version from git tags."""
    # Try git describe first
    try:
        version = run_command(["git", "describe", "--tags"], cwd=package_dir)
    except:
        # Fall back to latest tag
        tags = run_command(["git", "tag", "--sort=-version:refname"], cwd=package_dir)
        if not tags:
            error_exit(f"No git tags found in {package_dir}")
        version = tags.split('\n')[0]

    # Parse version to major.minor
    version = version.lstrip('v')  # Remove 'v' prefix if present
    parts = version.split('.')
    if len(parts) >= 2:
        return f"{parts[0]}.{parts[1]}"
    return parts[0]


def find_readme(package_dir):
    """Find README file in package directory."""
    for filename in ["README.md", "README.txt", "README.markdown"]:
        readme_path = package_dir / filename
        if readme_path.exists():
            return readme_path
    return None


def generate_documentation(package_dir, package_name):
    """Run interfazzle to generate documentation."""
    with tempfile.TemporaryDirectory() as temp_output_dir:
        # Check if build artifacts already exist
        build_db = package_dir / ".build" / "build.db"
        cmd = ["interfazzle", "generate", "--output-dir", temp_output_dir]
        if build_db.exists():
            cmd.append("--generate-only")

        # Run interfazzle with absolute temp directory path
        run_command(cmd, cwd=package_dir, capture_output=False)

        # Concatenate all markdown files
        temp_path = Path(temp_output_dir)
        markdown_files = sorted(temp_path.glob("**/*.md"))

        if not markdown_files:
            error_exit(f"No markdown files generated by interfazzle")

        content_parts = []

        # Add generated docs
        for md_file in markdown_files:
            with open(md_file, 'r') as f:
                content_parts.append(f.read())

        # Add README if exists
        readme_path = find_readme(package_dir)
        if readme_path:
            content_parts.append("\n\n---\n\n# Package README\n\n")
            with open(readme_path, 'r') as f:
                content_parts.append(f.read())

        return "\n\n".join(content_parts)
        # Temp directory is automatically cleaned up when exiting context


def main():
    if len(sys.argv) != 3:
        print("Usage: python3 generate_docs.py <module_or_package_name> <xcodeproj_path>")
        sys.exit(1)

    module_or_package = sys.argv[1]
    xcodeproj_path_str = sys.argv[2]
    xcodeproj_path = Path(xcodeproj_path_str)

    # Validate xcodeproj path
    if not xcodeproj_path.exists():
        error_exit(f"Xcode project not found: {xcodeproj_path}")

    project_dir = xcodeproj_path.parent
    docs_dir = project_dir / "dependency-docs"

    # Get dependency list and resolve package name
    print(f"Resolving package name for: {module_or_package}", file=sys.stderr)
    dependencies = get_all_dependencies(xcodeproj_path)
    package_name = resolve_module_to_package(module_or_package, dependencies)

    if package_name is None:
        error_exit(f"Could not find package for module: {module_or_package}")

    # Get package info
    package_info = dependencies[package_name]
    version = package_info.get("version", "unknown")

    # Parse version to major.minor
    version_parts = version.split('.')
    short_version = f"{version_parts[0]}.{version_parts[1]}" if len(version_parts) >= 2 else version_parts[0]

    # Check if docs already exist
    docs_filename = f"{package_name}-{short_version}.md"
    docs_path = docs_dir / docs_filename

    if docs_path.exists():
        print(f"Documentation already exists: {docs_path}", file=sys.stderr)
        print(docs_path)
        return

    # Find package in DerivedData
    print(f"Finding package '{package_name}' in DerivedData...", file=sys.stderr)
    project_name = xcodeproj_path.stem
    checkouts_dir = find_derived_data_path(project_name)
    package_dir = find_package_directory_in_derived_data(checkouts_dir, package_name)

    if package_dir is None:
        error_exit(f"Package '{package_name}' not found in DerivedData. Has the project been built?")

    # Generate documentation
    print(f"Generating documentation for {package_name} {short_version}...", file=sys.stderr)
    content = generate_documentation(package_dir, package_name)

    # Save documentation
    docs_dir.mkdir(exist_ok=True)
    with open(docs_path, 'w') as f:
        f.write(content)

    print(f"Documentation generated successfully!", file=sys.stderr)
    print(docs_path)


if __name__ == "__main__":
    main()
